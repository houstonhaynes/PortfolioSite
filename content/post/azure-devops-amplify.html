---
title: "Coaxing AWS Amplify to play well with Azure DevOps"
output:
  blogdown::html_page:
    toc: false
    toc_depth: 1
    fig_width: 8
    dev: "svg"
author: "Houston Haynes"
date: '2020-01-11T14:59:43+05:30'
featuredpath: img
featured: ADO_Amplify_thumb.png
description: Using a simple Azure DevOps Build Pipeline to feed Amplify for Continuous Integration and Deployment
draft: false
tags:
- AWS 
- CodeCommit
- Amplify
- Azure 
- DevOps
- Hugo
- Git
categories: 
- Sidebar
editor_options: 
  chunk_output_type: inline
---



<div id="starting-with-github-private-repo-sync" class="section level1">
<h1>Starting with GitHub Private Repo Sync</h1>
<p>This was a side project that turned into a work product. So the path to making this a reasonably secure, reliable process was not a first-class consideration it usually is in my work. That said, I found AWS Amplify and GitHub repo integration to be really slick. I started with a private GitHub repo as a crutch since it was so easy to configure with Amplify. I figured that <em>if</em> the site matured from a proof-of-concept to a fully fledges product, I could just move it over from a private GitHub repo to my company’s Azure Dev Ops instance - update the endpoint and PAT - and that, as they say, would be that.</p>
<div id="not-so-fast" class="section level2">
<h2>Not So Fast</h2>
<p>The first thing you’ll notice in the Amplify page for selecting the Git provider that Azure DevOps is <em>not</em> listed. So I thought “No worries. I’ll just treat ADO like any other Git repo and we’ll be good to go.” That was wrong, too. So I spent some time looking into how to mirror my Azure DevOps repo into AWS CodeCommit, and let Amplify take things from there. Azure DevOps has a task for handling Git mirroring, so it was a matter of wiring things up and letting a simple build pipeline do the heavy lifting.</p>
</div>
<div id="to-pat-or-not-to-pat" class="section level2">
<h2>To PAT or <em>not</em> to PAT</h2>
<p>AWS CodeCommit has an odd wrinkle to it that it doesn’t support generation of a PAT - or personal access token. After some research (mainly by reading open-ended support questions in various forums) I found that using the Git credentials for a service account is a proper substitute. The construction is akin to</p>
<pre><code class="json">$(AccessID:AccessKey)
</code></pre>
<p>where the value is stuffed into a variable within the Azure DevOps build task context. The rest of the task setup is pretty garden-variety boilerplate work.</p>
</div>
<div id="service-account-notes" class="section level2">
<h2>Service Account Notes</h2>
<p>I tried to cheat/short-cut the process by simply using my own AWS Admin (Git) credentials in the ADO Pipeline task, and it failed quite spectacularly. It turned out that the constructor for passing in the PAT would truncate the first part of my my Access ID (my email address) at the “@” symbol. So - I created an “Amplify” service account with the correct (minimal) permissions and everything worked as expected. But let this be a warning that if you use an account that uses an email address pattern for the AccessID, the script will break.</p>
</div>
<div id="an-understated-cicd-process" class="section level2">
<h2>An understated CI/CD process</h2>
<p>If you’re accustomed to setting up a highly instrument process per-branch in ADO (or any other build orchstrator) then Git mirroring is going to feel a bit light. But don’t let it fool you. It’s a bit counter-intuitive to set up a single build process (that only points to the repo level - not the branch) to perform the sync for any and all of your branches. But if you think about it - with a discplined code promotion procedure you’re only acting on one branch at a time. So even if the mirroring process reflexively updates both - only the branch with an active delta will be updated. So on the receiving end the CodeCommit repo will “see” an update <em>only</em> for branches where a change exists. In this case, with each environment (I just have an “int” and “main” branch) CodeCommit picks up the changes and Amplify performs the build and deployment for each branch respectively.</p>
</div>
</div>
<div id="worth-a-thousand-words" class="section level1">
<h1>Worth a Thousand Words</h1>
<p>I created this time-compressed video to illustrate a quick walkthrough of how the process operates. It includes a sample push to int and then merge to main - with the respective sync to the CodeCommit and follow-on Amplify deployments per environment.
{{% vimeo "435604451" %}}</p>
<div id="additional-work" class="section level2">
<h2>Additional Work</h2>
<p>There are still some wrinkles to iron out - mainly on the Azure DevOps side. It’s a fairly naive process - in that it “expects” to work every time - and for now I consider that a relatively low risk. However there should be some error/recovery processes instrumented - even if it’s just a notification on an error condition.</p>
</div>
</div>
<div id="summary" class="section level1">
<h1>Summary</h1>
<p>Really this sidebar is about two nits: 1. the PAT that’s not a PAT, and 2. a wrinkle in the Access ID name pattern that could cause an error. Otherwise it’s a relatively straight-forward and surprisingly light-weight process. The video is a fairly complete picture of how the mechanism operates, so feel free to watch and pause at the important highlights to see the working model. I really like it, and getting two <em>occasionally antagonistic</em> cloud spheres to play well together is always fun.</p>
</div>
